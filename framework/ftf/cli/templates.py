"""
Code Templates for Scaffolding (Sprint 3.0)

This module contains code templates for generating framework components.
Templates use Python f-strings for simplicity and enforce architectural
standards (e.g., warning docstrings in FormRequest).

Educational Note:
    Unlike Laravel which uses PHP Blade templates or Django which uses
    custom template syntax, we use Python f-strings because:
    1. No additional dependencies
    2. Type-safe and validated by MyPy
    3. Familiar to Python developers
    4. Easy to test and maintain

Templates Available:
    - MODEL_TEMPLATE: SQLAlchemy model with mixins
    - REPOSITORY_TEMPLATE: Repository inheriting BaseRepository
    - REQUEST_TEMPLATE: FormRequest with validation methods (includes warning)
    - FACTORY_TEMPLATE: Factory for test data generation
    - SEEDER_TEMPLATE: Seeder for database seeding
"""


def get_model_template(class_name: str, table_name: str) -> str:
    """
    Generate a SQLAlchemy 2.0 model with TimestampMixin and SoftDeletesMixin.
    
    Args:
        class_name: Name of the model class (e.g., "User", "Post")
        table_name: Name of the database table (e.g., "users", "posts")
    
    Returns:
        Formatted model code with SQLAlchemy 2.0 syntax
    
    Sprint 9.0 Changes:
        - Uses SQLAlchemy 2.0 syntax (Mapped, mapped_column)
        - Compatible with Hybrid Repository (Sprint 8.0)
    
    Example:
        >>> get_model_template("User", "users")
        # Returns model code with User class
    """
    return f'''"""
{class_name} Model

This module defines a {class_name} model for database operations.
Generated by Fast Track Framework CLI.

Sprint 9.0: Uses SQLAlchemy 2.0 (Mapped, mapped_column).
"""

from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column

from fast_query import Base, SoftDeletesMixin, TimestampMixin


class {class_name}(Base, TimestampMixin, SoftDeletesMixin):
    """
    {class_name} model.
    
    This model includes automatic timestamp management (created_at, updated_at)
    and soft delete functionality (deleted_at).
    
    Sprint 9.0:
        - Uses SQLAlchemy 2.0 syntax (Mapped, mapped_column)
        - Compatible with Hybrid Repository (Sprint 8.0)
        - Type-safe with full MyPy support
    
    Attributes:
        id: Primary key
        name: {class_name} name
        # Add more fields as needed
    
    Example:
        >>> user = User(name="Alice", email="alice@example.com")
        >>> await repo.create(user)  # repo is HybridRepository
    """
    
    __tablename__ = "{table_name}"
    
    # Primary key
    id: Mapped[int] = mapped_column(primary_key=True)
    
    # Fields
    name: Mapped[str] = mapped_column(String(100))
    
    # TODO: Add more columns here
    # Example:
    # email: Mapped[str] = mapped_column(String(255), unique=True)
    # is_active: Mapped[bool] = mapped_column(default=True)
    
    # TODO: Define relationships here
    # Example:
    # posts: Mapped[list["Post"]] = relationship("Post", back_populates="user")
    
    def __repr__(self) -> str:
        """String representation for debugging."""
        return f"<{class_name}(id={{self.id}}, name={{self.name}})>"
    '''


def get_repository_template(class_name: str, model_name: str) -> str:
    """
    Generate a repository inheriting BaseRepository (Sprint 8.0 modernized).
    
    Args:
        class_name: Name of the repository class (e.g., "UserRepository")
        model_name: Name of the model class (e.g., "User")
    
    Returns:
        Formatted repository code with Hybrid Repository pattern
    
    Sprint 9.0 Changes:
        - Repository uses Hybrid Pattern (convenience methods + native session access)
        - AsyncSession is injected via Container DI (not get_session())
    """
    return f'''"""
{class_name}

This module defines a repository for {model_name} operations.
Generated by Fast Track Framework CLI.

Sprint 9.0: Uses Hybrid Repository pattern (Sprint 8.0) with Container DI.
"""

from sqlalchemy.ext.asyncio import AsyncSession

from fast_query import BaseRepository
from app.models import {model_name}


class {class_name}(BaseRepository[{model_name}]):
    """
    Repository for {model_name} database operations.
    
    Inherits from BaseRepository (Hybrid Pattern - Sprint 8.0):
    - Convenience methods: find(id), create(), update(), delete(), all(), etc.
    - Native session access: self.session.execute(select(...)) for advanced queries
    
    Sprint 9.0:
        - AsyncSession is injected via Container DI
        - Can use both convenience methods and native session
        - Supports CTEs, Window Functions, Bulk Operations
    
    Example usage:
        >>> # Use convenience methods (recommended for simple operations)
        >>> user = await repo.find(123)
        >>> 
        >>> # Use native session for advanced queries
        >>> from sqlalchemy import select
        >>> stmt = select({model_name}).where(...)
        >>> result = await repo.session.execute(stmt)
    
    Available methods:
    - find(id): Find by primary key
    - find_or_fail(id): Find or raise RecordNotFound
    - all(): Get all records
    - paginate(page, per_page): Paginated results
    - create(data): Create new record
    - update(id, data): Update existing record
    - delete(id): Delete record (soft delete if mixin enabled)
    - query(): Get QueryBuilder for fluent queries
    - session: Native AsyncSession access for advanced queries (CTEs, Window Functions)
    
    Add custom query methods here.
    
    Example:
        >>> async def find_by_email(self, email: str) -> {model_name} | None:
        ...     stmt = select({model_name}).where({model_name}.email == email)
        ...     result = await self.session.execute(stmt)
        ...     return result.scalar_one_or_none()
    """
    
    def __init__(self, session: AsyncSession):
        """
        Initialize the repository with Container-injected AsyncSession.
        
        Args:
            session: AsyncSession for database operations (injected via Container)
        """
        super().__init__(session, {model_name})
    
    # TODO: Add custom query methods here
    # Example:
    # async def find_by_email(self, email: str) -> {model_name} | None:
    #     """Find {model_name.lower()} by email address using native session."""
    #     stmt = select({model_name}).where({model_name}.email == email)
    #     result = await self.session.execute(stmt)
    #     return result.scalar_one_or_none()
    '''


def get_request_template(class_name: str) -> str:
    """
    Generate a FormRequest with validation methods.

    This template includes the GOVERNANCE WARNING about side effects in rules().

    Args:
        class_name: Name of the request class (e.g., "StoreUserRequest")

    Returns:
        Formatted request code with warning docstring

    Example:
        >>> get_request_template("StoreUserRequest")
        # Returns request code with warning
    """
    return f'''"""
{class_name}

This module defines the form request for validation.
Generated by Fast Track Framework CLI.

⚠️ WARNING: rules() is for data validation only.
DO NOT mutate data or perform side effects here.
"""

from pydantic import EmailStr
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import User  # Import your model
from ftf.validation import FormRequest, Rule


class {class_name}(FormRequest):
    """
    Form request for validating data.

    This class combines Pydantic's structural validation with async
    database validation. It follows the "best of both worlds" approach:
    - Pydantic handles types, required fields, formats
    - async methods handle database checks (unique, exists)

    Attributes:
        # TODO: Define your fields here
        name: str
        email: EmailStr

    Example:
        >>> @app.post("/endpoint")
        ... async def create(request: {class_name} = Validate({class_name})):
        ...     # request is fully validated!
        ...     return {{"message": "Success"}}
    """

    # TODO: Define your fields with Pydantic validation
    name: str
    email: EmailStr

    async def authorize(self, session: AsyncSession) -> bool:
        """
        Determine if the user is authorized to make this request.

        Override this method to implement authorization logic. By default,
        all requests are authorized (returns True).

        Returns 403 Forbidden if this returns False.

        Args:
            session: AsyncSession for database queries

        Returns:
            bool: True if authorized, False otherwise

        Example:
            >>> async def authorize(self, session: AsyncSession) -> bool:
            ...     # Check if user is admin
            ...     current_user = await get_current_user()
            ...     return current_user.is_admin
        """
        return True

    async def rules(self, session: AsyncSession) -> None:
        """
        Define custom validation rules.

        ⚠️ WARNING: This method is for DATA VALIDATION ONLY.
        DO NOT:
        - Mutate data (self.field = new_value)
        - Perform side effects (send emails, update database)
        - Execute business logic (create records, process payments)

        Returns 422 Unprocessable Entity if validation fails.

        Args:
            session: AsyncSession for database queries

        Raises:
            ValidationError: If validation fails

        Example:
            >>> async def rules(self, session: AsyncSession) -> None:
            ...     # Check email is unique
            ...     await Rule.unique(session, User, "email", self.email)
            ...
            ...     # Custom validation
            ...     if self.age < 18:
            ...         self.stop("You must be 18 or older")
        """
        # TODO: Add validation rules here
        # Example: Check if email is unique
        # await Rule.unique(session, User, "email", self.email)
        pass
'''


def get_factory_template(class_name: str, model_name: str) -> str:
    """
    Generate a factory for test data generation (Sprint 9.0 modernized).
    
    Args:
        class_name: Name of the factory class (e.g., "UserFactory")
        model_name: Name of the model class (e.g., "User")
    
    Returns:
        Formatted factory code compatible with Container DI and Hybrid Repository.
    
    Sprint 9.0 Changes:
        - Factory works with Container DI for AsyncSession
        - Compatible with Hybrid Repository (Sprint 8.0)
    """
    return f'''"""
{class_name}

This module defines a factory for generating {model_name} test data.
Generated by Fast Track Framework CLI.

Sprint 9.0: Uses Container DI for AsyncSession.
"""

from typing import Any

from fast_query import Factory
from app.models import {model_name}


class {class_name}(Factory[{model_name}]):
    """
    Factory for generating {model_name} instances.
    
    This factory uses Faker to generate realistic fake data for testing.
    It inherits from Factory which provides:
    - create(): Create one instance
    - create_batch(count): Create multiple instances
    - state(callable): Modify attributes
    - Relationship hooks (if defined)
    
    Sprint 9.0:
        - AsyncSession is injected via Container DI
        - Compatible with Hybrid Repository (Sprint 8.0)
        - No more get_session() calls - uses Container.resolve()
    
    Example:
        >>> # Factory resolves its own AsyncSession from Container
        >>> factory = UserFactory()  # Container DI
        >>> user = await factory.create()
        >>> users = await factory.create_batch(10)
    """
    
    _model_class = {model_name}
    
    def definition(self) -> dict[str, Any]:
        """
        Define the default attributes for the model.
        
        This method uses self.faker to generate fake data. Faker provides
        many useful generators like name(), email(), address(), etc.
        
        Returns:
            dict: Default attributes for {model_name}
        
        Example:
            >>> def definition(self) -> dict[str, Any]:
            ...     return {{
            ...         "name": self.faker.name(),
            ...         "email": self.faker.email(),
            ...     }}
        """
        return {{
            "name": self.faker.name(),
            # TODO: Add more fields here
            # Example:
            # "email": self.faker.email(),
            # "is_active": True,
        }}
    
    # TODO: Add relationship hooks here
    # Example:
    # async def has_posts(self, count: int = 3) -> "{class_name}":
    #     """Create user with posts."""
    #     def after_create(user: User) -> None:
    #         self._after_create_callbacks.append(
    #             lambda: PostFactory(self.session).create_batch(count, user_id=user.id)
    #         )
    #         self._after_create_callbacks.append(after_create)
    #         return self
    '''


def get_seeder_template(class_name: str) -> str:
    """
    Generate a seeder for database seeding (Sprint 9.0 modernized).
    
    Args:
        class_name: Name of the seeder class (e.g., "UserSeeder")
    
    Returns:
        Formatted seeder code compatible with Container DI and Hybrid Repository.
    
    Sprint 9.0 Changes:
        - AsyncSession is injected via Container DI
        - Compatible with Hybrid Repository (Sprint 8.0)
        - Factories can be injected as dependencies
    """
    return f'''"""
{class_name}

This module defines a database seeder.
Generated by Fast Track Framework CLI.

Sprint 9.0: Uses Container DI for AsyncSession.
"""

from fast_query import Seeder

# Import your factories here (can be injected via Container DI!)
# Example:
# from tests.factories import UserFactory


class {class_name}(Seeder):
    """
    Seeder for populating database.
    
    This seeder uses factories to generate test/initial data.
    It inherits from Seeder which provides:
    - self.session: AsyncSession for database operations (injected via Container)
    - run(): Method to execute seeding logic
    
    Sprint 9.0:
        - AsyncSession is injected via Container DI
        - Dependencies (Factories, Repositories) can be injected via __init__
        - Compatible with Hybrid Repository (Sprint 8.0)
    
    Example:
        >>> class UserSeeder(Seeder):
        ...     def __init__(self, session: AsyncSession, user_factory: UserFactory):
        ...         self.session = session  # Container DI
        ...         self.user_factory = user_factory  # Dependency injection
        ...
        ...     async def run(self):
        ...         users = await self.user_factory.create_batch(10)
        ...         for user in users:
        ...             await repo.create(user)
    """
    
    async def run(self) -> None:
        """
        Run the database seeder.
        
        This method is called when you execute `ftf db:seed`.
        Use factories to create test data here.
        
        Sprint 9.0:
            - self.session is injected via Container DI
            - Factories can be injected as dependencies in __init__
        - Uses Hybrid Repository pattern (Sprint 8.0)
        
        Example:
            >>> async def run(self) -> None:
            ...     users = await self.user_factory.create_batch(10)
            ...     for user in users:
            ...         await repo.create(user)
            ...     pass
        """
        # TODO: Add seeding logic here
        # Example:
        # factory = UserFactory(self.session)
        # await factory.create_batch(10)
        # pass
    '''


def get_event_template(class_name: str) -> str:
    """
    Generate an Event class (DTO).

    Args:
        class_name: Name of the event class (e.g., "UserRegistered")

    Returns:
        Formatted event code

    Example:
        >>> get_event_template("UserRegistered")
        # Returns event code
    """
    return f'''"""
{class_name} Event

This module defines an event that can be dispatched through the Event Bus.
Generated by Fast Track Framework CLI.

Educational Note:
    Events are DTOs (Data Transfer Objects) that carry information about
    something that happened. They should be immutable and contain only data.
"""

from dataclasses import dataclass

from ftf.events import Event


@dataclass
class {class_name}(Event):
    """
    Event fired when {class_name.lower().replace("event", "")} occurs.

    This event carries information about the occurrence and can be handled
    by multiple listeners concurrently.

    Attributes:
        # TODO: Define your event attributes here
        # Example:
        # user_id: int
        # email: str
        # timestamp: datetime

    Example:
        >>> event = {class_name}(user_id=1, email="user@test.com")
        >>> await dispatch(event)
    """

    # TODO: Add your event attributes here
    # Example for a user registration event:
    # user_id: int
    # email: str
    # name: str
    # timestamp: datetime = field(default_factory=datetime.utcnow)

    pass
'''


def get_listener_template(class_name: str, event_name: str = "Event") -> str:
    """
    Generate a Listener class for handling events.

    Args:
        class_name: Name of the listener class (e.g., "SendWelcomeEmail")
        event_name: Name of the event this listener handles

    Returns:
        Formatted listener code

    Example:
        >>> get_listener_template("SendWelcomeEmail", "UserRegistered")
        # Returns listener code
    """
    return f'''"""
{class_name} Listener

This module defines a listener that handles {event_name} events.
Generated by Fast Track Framework CLI.

Educational Note:
    Listeners are resolved from the IoC Container, so you can inject
    dependencies (repositories, services, etc.) via __init__.
"""

from ftf.events import Listener

# TODO: Import your event
# from ftf.events.user_registered import UserRegistered
from ftf.events import Event as {event_name}  # Replace with actual import


class {class_name}(Listener[{event_name}]):
    """
    Handles {event_name} events.

    This listener is resolved from the IoC Container, allowing dependency
    injection of repositories, services, mailers, etc.

    Example:
        >>> class {class_name}(Listener[UserRegistered]):
        ...     def __init__(self, mailer: MailService, user_repo: UserRepository):
        ...         self.mailer = mailer
        ...         self.user_repo = user_repo
        ...
        ...     async def handle(self, event: UserRegistered) -> None:
        ...         user = await self.user_repo.find(event.user_id)
        ...         await self.mailer.send(user.email, "Welcome!")
    """

    def __init__(self) -> None:
        """
        Initialize the listener.

        TODO: Add dependencies here via dependency injection.

        Example:
            def __init__(self, mailer: MailService):
                self.mailer = mailer
        """
        pass

    async def handle(self, event: {event_name}) -> None:
        """
        Handle the {event_name} event.

        This method is called when the event is dispatched. Add your
        business logic here.

        Args:
            event: The event instance containing data

        Example:
            >>> async def handle(self, event: UserRegistered) -> None:
            ...     # Send welcome email
            ...     await self.mailer.send(
            ...         to=event.email,
            ...         subject="Welcome!",
            ...         body=f"Hello {{event.name}}!"
            ...     )
        """
        # TODO: Add your event handling logic here
        # Example:
        # await self.mailer.send(event.email, "Welcome!")
        pass
'''


def get_job_template(class_name: str) -> str:
    """
    Generate a Job class for background processing.

    Args:
        class_name: Name of the job class (e.g., "SendWelcomeEmail")

    Returns:
        Formatted job code

    Example:
        >>> get_job_template("SendWelcomeEmail")
        # Returns job code with async handle() method
    """
    return f'''"""
{class_name} Job

This module defines a background job.
Generated by Fast Track Framework CLI.
"""

from ftf.jobs import Job

# Import your dependencies here
# from ftf.repositories import UserRepository
# from ftf.services import MailerService


class {class_name}(Job):
    """
    {class_name} background job.

    This job processes work asynchronously in the background. Jobs can receive
    dependencies through the IoC Container, making them testable and maintainable.

    Dependencies are injected via __init__, and payload attributes are set
    by the runner before handle() is called.

    Example:
        >>> # Define job with dependencies
        >>> class {class_name}(Job):
        ...     def __init__(self, mailer: MailerService):
        ...         self.mailer = mailer
        ...         self.email: str = ""  # Set by payload
        ...
        ...     async def handle(self) -> None:
        ...         await self.mailer.send(self.email, "Hello!")
        >>>
        >>> # Dispatch job
        >>> await {class_name}.dispatch(email="user@test.com")
    """

    def __init__(self) -> None:
        """
        Initialize the job with dependencies.

        Dependencies are resolved from the IoC Container. Add any repositories,
        services, or other dependencies as parameters.

        Example:
            >>> def __init__(self, user_repo: UserRepository, mailer: MailerService):
            ...     self.user_repo = user_repo
            ...     self.mailer = mailer
            ...     # Payload attributes (set by dispatcher):
            ...     self.user_id: int = 0
            ...     self.email: str = ""
        """
        # TODO: Add dependencies as parameters
        # TODO: Initialize payload attributes with default values
        pass

    async def handle(self) -> None:
        """
        Execute the job logic.

        This method contains the actual work to be performed. Payload attributes
        are already set by the runner before this method is called.

        Raises:
            Exception: Any exceptions will be logged by SAQ and can trigger retries

        Example:
            >>> async def handle(self) -> None:
            ...     user = await self.user_repo.find(self.user_id)
            ...     await self.mailer.send(
            ...         to=user.email,
            ...         subject="Welcome!",
            ...         body=f"Hello {{user.name}}!"
            ...     )
        """
        # TODO: Add your job logic here
        # Example:
        # user = await self.user_repo.find(self.user_id)
        # await self.mailer.send(user.email, "Welcome!")
        pass
'''


def get_auth_controller_template() -> str:
    """Generate an authentication controller with login, register, and me endpoints."""
    return '''"""
Authentication Controller (Generated by ftf make:auth)

This controller handles user authentication endpoints:
- POST /auth/register - Create new user account
- POST /auth/login - Authenticate and get JWT token
- GET /auth/me - Get current authenticated user
"""

from fastapi import APIRouter, HTTPException, status

from ftf.auth import CurrentUser, create_access_token, hash_password, verify_password
from ftf.http.requests.auth.login_request import LoginRequest
from ftf.http.requests.auth.register_request import RegisterRequest
from ftf.repositories.user_repository import UserRepository

router = APIRouter(prefix="/auth", tags=["authentication"])


@router.post("/register", status_code=status.HTTP_201_CREATED)
async def register(
    request: RegisterRequest,
    user_repo: UserRepository,
) -> dict:
    """
    Register a new user account.

    This endpoint:
    1. Validates the request data (email, password, name)
    2. Checks if email is already registered (via FormRequest validation)
    3. Hashes the password with bcrypt
    4. Creates the user in the database
    5. Returns success message

    Args:
        request: Validated registration data
        user_repo: User repository (auto-injected)

    Returns:
        dict: Success message with user ID

    Raises:
        HTTPException: 422 if validation fails (duplicate email, weak password, etc.)
    """
    # Hash the password before storing
    hashed_password = hash_password(request.password)

    # Create the user
    user = await user_repo.create({
        "name": request.name,
        "email": request.email,
        "password": hashed_password,
    })

    return {
        "message": "User registered successfully",
        "user_id": user.id,
    }


@router.post("/login")
async def login(
    request: LoginRequest,
    user_repo: UserRepository,
) -> dict:
    """
    Authenticate user and return JWT access token.

    This endpoint:
    1. Validates the request data (email, password)
    2. Finds the user by email
    3. Verifies the password hash
    4. Generates a JWT access token
    5. Returns the token

    Args:
        request: Login credentials
        user_repo: User repository (auto-injected)

    Returns:
        dict: Access token and token type

    Raises:
        HTTPException: 401 if credentials are invalid
    """
    # Find user by email
    user = await user_repo.where("email", request.email).first()

    # Check if user exists and password is correct
    if not user or not verify_password(request.password, user.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Generate JWT token
    access_token = create_access_token(data={"user_id": user.id})

    return {
        "access_token": access_token,
        "token_type": "bearer",
    }


@router.get("/me")
async def get_current_user_info(user: CurrentUser) -> dict:
    """
    Get the currently authenticated user's information.

    This endpoint demonstrates route protection with JWT.
    The CurrentUser dependency automatically:
    1. Extracts the JWT token from the Authorization header
    2. Verifies the token signature and expiration
    3. Fetches the user from the database
    4. Returns the user instance

    Args:
        user: Current authenticated user (auto-injected via JWT)

    Returns:
        dict: User information

    Example:
        GET /auth/me
        Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

        Response:
        {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com"
        }
    """
    return {
        "id": user.id,
        "name": user.name,
        "email": user.email,
    }
'''


def get_login_request_template() -> str:
    """Generate a login request with email and password validation."""
    return '''"""
Login Request (Generated by ftf make:auth)

Validates user login credentials.
"""

from ftf.validation import FormRequest, Rule


class LoginRequest(FormRequest):
    """
    Validates login credentials.

    Fields:
        - email: Required, must be valid email format
        - password: Required, minimum length
    """

    email: str
    password: str

    def rules(self) -> dict[str, list[Rule]]:
        """
        Define validation rules for login.

        ⚠️ WARNING: This method is for DATA VALIDATION ONLY.
        DO NOT perform side effects here (database queries, API calls, etc.)
        Side effects belong in the controller AFTER validation passes.
        """
        return {
            "email": [
                Rule.required(),
                Rule.email(),
            ],
            "password": [
                Rule.required(),
                Rule.min_length(6),
            ],
        }
'''


def get_register_request_template() -> str:
    """Generate a register request with validation including unique email."""
    return '''"""
Register Request (Generated by ftf make:auth)

Validates new user registration data.
"""

from ftf.validation import FormRequest, Rule


class RegisterRequest(FormRequest):
    """
    Validates user registration data.

    Fields:
        - name: Required, minimum 2 characters
        - email: Required, valid email, must be unique
        - password: Required, minimum 8 characters
        - password_confirmation: Required, must match password
    """

    name: str
    email: str
    password: str
    password_confirmation: str

    def rules(self) -> dict[str, list[Rule]]:
        """
        Define validation rules for registration.

        ⚠️ WARNING: This method is for DATA VALIDATION ONLY.
        DO NOT perform side effects here (database queries, API calls, etc.)
        Side effects belong in the controller AFTER validation passes.
        """
        return {
            "name": [
                Rule.required(),
                Rule.min_length(2),
                Rule.max_length(100),
            ],
            "email": [
                Rule.required(),
                Rule.email(),
                Rule.unique("users", "email"),  # Check email uniqueness in database
            ],
            "password": [
                Rule.required(),
                Rule.min_length(8),
                Rule.max_length(100),
            ],
            "password_confirmation": [
                Rule.required(),
                Rule.confirmed("password"),  # Must match password field
            ],
        }
'''


def get_user_model_template() -> str:
    """Generate a User model with authentication fields."""
    return '''"""
User Model (Generated by ftf make:auth)

User model with authentication fields (email, password).
"""

from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column

from fast_query import Base, SoftDeletesMixin, TimestampMixin


class User(Base, TimestampMixin, SoftDeletesMixin):
    """
    User model with authentication.

    This model includes:
    - Auto-timestamps (created_at, updated_at)
    - Soft deletes (deleted_at)
    - Authentication fields (email, password)

    Attributes:
        id: Primary key
        name: User's full name
        email: Unique email address
        password: Bcrypt-hashed password (NEVER store plain text!)
    """

    __tablename__ = "users"

    # Primary key
    id: Mapped[int] = mapped_column(primary_key=True)

    # User information
    name: Mapped[str] = mapped_column(String(100))
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)

    # Authentication (password is hashed with bcrypt)
    password: Mapped[str] = mapped_column(String(255))

    # TODO: Add more fields as needed
    # Example:
    # is_active: Mapped[bool] = mapped_column(default=True)
    # is_admin: Mapped[bool] = mapped_column(default=False)

    def __repr__(self) -> str:
        """String representation for debugging."""
        return f"<User(id={self.id}, email={self.email})>"
'''


def get_user_repository_template() -> str:
    """Generate a UserRepository."""
    return '''"""
User Repository (Generated by ftf make:auth)

Repository for User database operations.
"""

from fast_query import BaseRepository
from ftf.models.user import User


class UserRepository(BaseRepository[User]):
    """
    User repository with CRUD operations.

    Inherits all methods from BaseRepository:
    - create(data)
    - find(id)
    - find_or_fail(id)
    - update(id, data)
    - delete(id)
    - all()
    - where(column, value)
    - paginate(page, per_page)

    Add custom user-specific methods here as needed.
    """

    # Example custom method:
    # async def find_by_email(self, email: str) -> User | None:
    #     """Find user by email address."""
    #     return await self.where("email", email).first()
'''


def get_middleware_template(name: str) -> str:
    """Generate a Middleware class template (Sprint 3.4)."""
    # Convert name to snake_case for import path
    import re
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    snake_name = re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()

    return f'''"""
{name} Middleware (Generated by ftf make:middleware)

This middleware intercepts HTTP requests and responses, allowing you to:
- Log requests and responses
- Authenticate users
- Add custom headers
- Rate limiting
- Request/response transformation

Educational Note:
    Middleware follows the "onion" pattern where each layer wraps the next.
    The request flows through all middleware layers before reaching the route
    handler, and the response flows back through in reverse order.

    Example flow:
        Request → Middleware A → Middleware B → Route Handler
        Response ← Middleware A ← Middleware B ← Route Handler

Usage:
    from starlette.middleware.base import BaseHTTPMiddleware
    from ftf.http.middleware.{snake_name} import {name}

    app = FastTrackFramework()
    app.add_middleware({name})

    # Or use directly with BaseHTTPMiddleware
    app.add_middleware(BaseHTTPMiddleware, dispatch={name}().dispatch)

Comparison with Laravel:
    Laravel middleware uses handle() method with $next closure.
    FastAPI/Starlette uses dispatch() method with call_next function.

    Laravel:
        public function handle($request, Closure $next) {{
            // Before
            $response = $next($request);
            // After
            return $response;
        }}

    FastAPI/Starlette:
        async def dispatch(self, request, call_next):
            # Before
            response = await call_next(request)
            # After
            return response
"""

from typing import Any

from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response


class {name}(BaseHTTPMiddleware):
    """
    {name} middleware for HTTP request/response processing.

    This middleware can be used to:
    - TODO: Describe what this middleware does

    Example:
        >>> app = FastTrackFramework()
        >>> app.add_middleware({name})
        >>>
        >>> @app.get("/api/users")
        >>> async def get_users():
        ...     # This request will flow through {name} middleware
        ...     return {{"users": []}}
    """

    async def dispatch(self, request: Request, call_next: Any) -> Response:
        """
        Process the HTTP request and response.

        This method is called for every HTTP request. You can:
        - Inspect/modify the request before the route handler
        - Inspect/modify the response after the route handler
        - Short-circuit the request (return early without calling route handler)
        - Add timing, logging, error handling, etc.

        Args:
            request: The incoming HTTP request
            call_next: Function to call the next middleware/route handler

        Returns:
            Response: The HTTP response (possibly modified)

        Example:
            >>> async def dispatch(self, request, call_next):
            ...     # Before request (logging, auth, etc.)
            ...     print(f"Request: {{request.method}} {{request.url}}")
            ...
            ...     # Call next middleware/route handler
            ...     response = await call_next(request)
            ...
            ...     # After request (add headers, log response, etc.)
            ...     response.headers["X-Custom-Header"] = "value"
            ...     return response

        Educational Note:
            You MUST await call_next(request) to continue the request flow.
            If you don't call it, the route handler never executes!

            To short-circuit (return early):
                if not request.headers.get("Authorization"):
                    return Response("Unauthorized", status_code=401)
        """
        # ------------------------------------------------------------------
        # BEFORE REQUEST
        # Add code here to run before the route handler executes
        # Examples:
        #   - Logging: log request method, path, headers
        #   - Authentication: verify JWT token
        #   - Rate limiting: check if user exceeded request limit
        #   - Request transformation: modify headers, body, etc.
        # ------------------------------------------------------------------

        # TODO: Add your "before" logic here
        # Example:
        # if not self._is_authenticated(request):
        #     return Response("Unauthorized", status_code=401)

        # ------------------------------------------------------------------
        # CALL NEXT MIDDLEWARE / ROUTE HANDLER
        # This is where the request actually gets processed
        # ------------------------------------------------------------------
        response: Response = await call_next(request)

        # ------------------------------------------------------------------
        # AFTER REQUEST
        # Add code here to run after the route handler executes
        # Examples:
        #   - Add custom headers: response.headers["X-..."] = "..."
        #   - Logging: log response status, timing
        #   - Response transformation: modify body, status code
        # ------------------------------------------------------------------

        # TODO: Add your "after" logic here
        # Example:
        # response.headers["X-Processed-By"] = "{name}"

        return response


# Optional: Helper method for reusable logic
# def _is_authenticated(self, request: Request) -> bool:
#     """Check if request is authenticated."""
#     token = request.headers.get("Authorization")
#     return token is not None and token.startswith("Bearer ")
'''


def to_snake_case(name: str) -> str:
    """Convert CamelCase to snake_case for filename."""
    import re
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


# Template mapping for easy access
TEMPLATES = {
    "model": get_model_template,
    "repository": get_repository_template,
    "request": get_request_template,
    "factory": get_factory_template,
    "seeder": get_seeder_template,
    "event": get_event_template,
    "listener": get_listener_template,
    "job": get_job_template,
    "middleware": get_middleware_template,
    "auth_controller": get_auth_controller_template,
    "login_request": get_login_request_template,
    "register_request": get_register_request_template,
    "user_model": get_user_model_template,
    "user_repository": get_user_repository_template,
}


def get_command_template(name: str) -> str:
    """Generate a custom CLI command template (Sprint 3.5)."""
    # Convert to snake_case for module naming
    import re
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
    snake_name = re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()

    return f'''"""
{name} Command (Generated by ftf make:command)

This is a custom CLI command that extends the ftf CLI with domain-specific
functionality.

Usage:
    ftf {name.lower()} [OPTIONS]

Educational Note:
    Custom commands allow you to add project-specific tooling to the ftf CLI.
    This is useful for:
    - Deployment scripts
    - Database maintenance
    - Data migrations
    - Report generation
    - Custom automation

    Unlike Laravel (which has command auto-discovery via namespaces),
    you need to manually register this command in src/ftf/cli/main.py.

Registration:
    Add this to src/ftf/cli/main.py:

    from ftf.cli.commands.{snake_name} import app as {snake_name}_app
    app.add_typer({snake_name}_app, name="{name.lower()}")

Comparison with Laravel:
    Laravel (Artisan):
        php artisan make:command DeployCommand
        // Auto-registered via $commands property in Kernel.php

    Fast Track:
        ftf make:command deploy
        // Manual registration in main.py (for now)
"""

import typer
from rich.console import Console

# Create command group
app = typer.Typer()
console = Console()


@app.command()
def main(
    option: str = typer.Option(None, "--option", "-o", help="Example option"),
    flag: bool = typer.Option(False, "--flag", "-f", help="Example flag"),
) -> None:
    """
    {name} command - Add description here.

    This command performs [describe what it does here].

    Args:
        option: Example option parameter
        flag: Example boolean flag

    Example:
        $ ftf {name.lower()} --option value
        $ ftf {name.lower()} --flag
    """
    console.print(f"[bold cyan]Running {name} command...[/bold cyan]")

    # TODO: Implement your command logic here
    if option:
        console.print(f"[green]Option value:[/green] {{option}}")

    if flag:
        console.print("[green]Flag is enabled[/green]")

    # Example: Execute operations
    try:
        # Add your command logic here
        console.print("[green]✓ Command completed successfully![/green]")
    except Exception as e:
        console.print(f"[red]✗ Error: {{e}}[/red]")
        raise typer.Exit(code=1)


# Optional: Add subcommands
# @app.command("subcommand")
# def subcommand():
#     """Subcommand description."""
#     console.print("Subcommand executed")
'''


def get_rule_template(class_name: str) -> str:
    """
    Template for a custom Validation Rule (Pydantic AfterValidator).

    Args:
        class_name: Name of the validation rule class (e.g., "CpfIsValid")

    Returns:
        Formatted validation rule code

    Example:
        >>> get_rule_template("CpfIsValid")
        # Returns validator class code with __call__ method
    """
    return f'''"""
{class_name} Validation Rule.

This module defines a custom validation rule using Pydantic's AfterValidator pattern.
Generated by Fast Track Framework CLI.
"""

from typing import Any

from ftf.i18n import trans


class {class_name}:
    """
    Validate that the input meets specific criteria.

    Usage:
        from typing import Annotated
        from pydantic import AfterValidator, BaseModel

        class MyModel(BaseModel):
            field: Annotated[str, AfterValidator({class_name}())]

    Educational Note:
        This follows Pydantic v2's pattern for custom validators:
        - The class is callable (implements __call__)
        - Returns the value if valid (can be transformed)
        - Raises ValueError if validation fails
        - Uses ftf.i18n for error messages (multi-language support)

    Comparison with Laravel:
        Laravel:
            php artisan make:rule Uppercase
            // Implements Rule interface with passes() method

        Fast Track:
            ftf make:rule CpfIsValid
            // Callable class used with Pydantic AfterValidator
    """

    def __init__(self) -> None:
        """
        Initialize validator with any required parameters.

        Example:
            def __init__(self, min_length: int = 11) -> None:
                self.min_length = min_length
        """
        # TODO: Add initialization parameters here
        pass

    def __call__(self, value: Any) -> Any:
        """
        Validate the value.

        Args:
            value: The field value to validate

        Returns:
            The valid value (can be transformed if needed)

        Raises:
            ValueError: If validation fails

        Example:
            def __call__(self, value: str) -> str:
                if not value.isdigit() or len(value) != 11:
                    raise ValueError(trans("validation.invalid_cpf"))
                return value
        """
        # TODO: Implement validation logic
        # if not is_valid(value):
        #     raise ValueError(trans("validation.custom_rule_key"))

        return value
'''


def get_lang_template(locale: str) -> str:
    """Generate a translation JSON file template (Sprint 3.5)."""
    # Provide a skeleton with common translation keys
    return '''{
  "auth.failed": "These credentials do not match our records.",
  "auth.throttle": "Too many login attempts. Please try again in :seconds seconds.",
  "auth.password_changed": "Password changed successfully.",

  "validation.required": "The :field field is required.",
  "validation.email": "The :field must be a valid email address.",
  "validation.min": "The :field must be at least :min characters.",
  "validation.max": "The :field may not be greater than :max characters.",
  "validation.confirmed": "The :field confirmation does not match.",
  "validation.unique": "The :field has already been taken.",
  "validation.exists": "The selected :field is invalid.",
  
  "http.not_found": "Resource not found.",
  "http.unauthorized": "Unauthorized.",
  "http.forbidden": "Forbidden.",
  "http.unprocessable": "The given data was invalid.",
  "http.internal_error": "Internal server error.",
  
  "common.success": "Success!",
  "common.error": "An error occurred.",
  "common.loading": "Loading...",
  "common.save": "Save",
  "common.cancel": "Cancel",
  "common.delete": "Delete"
}
'''


def get_mailable_template(class_name: str) -> str:
    """
    Generate a Mailable class for sending emails (Sprint 4.0).

    Args:
        class_name: Name of the mailable class (e.g., "WelcomeEmail", "InvoiceEmail")

    Returns:
        Formatted mailable code with build() method

    Example:
        >>> get_mailable_template("WelcomeEmail")
        # Returns mailable code with WelcomeEmail class
    """
    return f'''"""
{class_name} Mailable

This module defines an email mailable for sending {class_name.replace("Email", "").lower()} emails.
Generated by Fast Track Framework CLI.
"""

from ftf.mail import Mailable


class {class_name}(Mailable):
    """
    {class_name} mailable.

    This mailable is responsible for composing and sending {class_name.replace("Email", "").lower()} emails.
    It uses the Builder Pattern for fluent email composition.

    Attributes:
        # TODO: Add mailable attributes here (e.g., user, order, etc.)

    Example Usage:
        ```python
        from mail.{class_name.lower().replace("email", "_email")} import {class_name}
        from ftf.mail import Mail

        # Send immediately
        await Mail.send({class_name}(...))

        # Fluent API with recipients
        await Mail.to("user@example.com", "John Doe").send({class_name}(...))

        # Queue for background processing
        await Mail.to("user@example.com").queue({class_name}(...))
        ```

    Educational Note:
        Mailables separate email composition from delivery. This provides:
        - Testability: Easy to test email content without sending
        - Reusability: Same mailable can be sent to different recipients
        - Maintainability: Email logic is centralized
    """

    def __init__(self) -> None:
        """
        Initialize mailable.

        Args:
            # TODO: Add constructor parameters (e.g., user: User)
        """
        super().__init__()

        # TODO: Store constructor parameters as instance variables
        # Example:
        # self.user = user

    async def build(self) -> None:
        """
        Build email content.

        This method defines the email structure using fluent builder methods:
        - subject(): Set email subject
        - from_(): Set sender address
        - view(): Use Jinja2 template
        - text(): Set plain text body
        - html(): Set HTML body
        - attach(): Add file attachment

        Example:
            ```python
            async def build(self) -> None:
                self.subject("Welcome to Our App!")
                self.from_("noreply@example.com", "My App")
                self.view("mail.welcome", {{"user": self.user}})
            ```

        Note:
            This is called automatically when the email is sent.
            You don't need to call it directly.
        """
        # TODO: Implement email composition
        # Example with template:
        # self.subject("Your subject here")
        # self.from_("noreply@example.com", "My App")
        # self.view("mail.template_name", {{"variable": "value"}})

        # Example with plain text:
        # self.subject("Your subject here")
        # self.from_("noreply@example.com", "My App")
        # self.text("Plain text email content")

        # Example with HTML:
        # self.subject("Your subject here")
        # self.from_("noreply@example.com", "My App")
        # self.html("<h1>HTML email content</h1>")

        # Example with attachment:
        # self.subject("Your subject here")
        # self.from_("noreply@example.com", "My App")
        # self.view("mail.invoice", {{"invoice": self.invoice}})
        # self.attach("/path/to/file.pdf", "invoice.pdf", "application/pdf")

        self.subject("TODO: Set your email subject")
        self.from_("noreply@example.com", "My App")
        self.text("TODO: Set your email content")
'''


def get_resource_template(class_name: str, model_name: str) -> str:
    """
    Generate an API Resource for transforming models to JSON.

    Args:
        class_name: Name of the resource class (e.g., "UserResource", "PostResource")
        model_name: Name of the model being transformed (e.g., "User", "Post")

    Returns:
        Formatted resource code with proper imports and structure

    Example:
        >>> get_resource_template("UserResource", "User")
        # Returns resource code with UserResource class
    """
    return f'''"""
{class_name} - API Resource

This resource transforms {model_name} models into JSON responses.
Generated by Fast Track Framework CLI.

Usage:
------
Single resource:
    {class_name}.make({model_name.lower()}).resolve()
    # Returns: {{"data": {{"id": 1, ...}}}}

Collection:
    {class_name}.collection({model_name.lower()}s).resolve()
    # Returns: {{"data": [{{...}}, {{...}}]}}

Educational Note:
----------------
API Resources decouple your database schema from your API response format.
This allows you to:
- Rename fields (user_id -> userId for camelCase APIs)
- Format data (datetime -> ISO 8601 string)
- Hide sensitive fields (password, tokens)
- Add computed fields (full_name from first_name + last_name)
- Control relationships (only include when eager-loaded)
- Conditional fields (based on permissions)
"""

from typing import Any

from ftf.resources import JsonResource, MISSING

try:
    from fastapi import Request
except ImportError:
    Request = None  # type: ignore

from ftf.models.{model_name.lower()} import {model_name}


class {class_name}(JsonResource[{model_name}]):
    """
    Transform {model_name} model to API response.

    This resource controls exactly what data is exposed in your API
    and how it's formatted.
    """

    def to_array(self, request: Request | None = None) -> dict[str, Any]:
        """
        Transform {model_name} to dictionary.

        Args:
            request: Optional FastAPI request for conditional logic

        Returns:
            Dictionary representation of the {model_name}

        Example:
            {{
                "id": 1,
                "name": "...",
                # Add more fields here
            }}
        """
        return {{
            "id": self.resource.id,
            # TODO: Add more fields here

            # Example: Format datetime
            # "created_at": self.resource.created_at.isoformat(),

            # Example: Conditional field (only for admins)
            # "email": self.when(is_admin(request), self.resource.email),

            # Example: Computed field
            # "full_name": f"{{self.resource.first_name}} {{self.resource.last_name}}",

            # Example: Nested resource
            # "user": UserResource.make(self.resource.user).to_array(request)
            #         if self.when_loaded("user") is not MISSING
            #         else MISSING,
        }}


def get_controller_template(name: str) -> str:
    """
    Generate a Controller class.

    Args:
        name: Name of the controller (e.g., "UserController", "ProductController")

    Returns:
        Formatted controller code
    """
    resource_name = name.replace("Controller", "").lower() + "s"
    model_name = name.replace("Controller", "")

    # Escape complex expressions in f-string
    repo_snake = model_name.lower()
    repo_name_upper = model_name.upper()

    return f"""from typing import Any

from ftf.http import Controller, Get, Post, Request

from ftf.http import Inject
from sqlalchemy.ext.asyncio import AsyncSession
from ftf.validation import FormRequest
from fast_query import BaseRepository

if True:
    from workbench.app.repositories.{repo_snake}_repository import {repo_snake}Repository

class {name}(Controller):
    \"\"\"
    Controller for {resource_name}.
    \"\"\"

    @Get(\"/{resource_name}\")
    async def index(self) -> Any:
        \"\"\"
        List all items.

        Returns:
            List of {resource_name}
        \"\"\"
        if True:
            repo = {repo_snake}Repository = Inject({repo_snake}Repository)
            items = await repo.all()
            return items

    @Get(\"/{resource_name}/{{id}}\")
    async def show(self, id: int) -> Any:
        \"\"\"
        Show single item by ID.

        Args:
            id: Item ID

        Returns:
            Single item
        \"\"\"
        if True:
            repo = {repo_snake}Repository = Inject({repo_snake}Repository)
            item = await repo.find_or_fail(id)
            return item

    @Post(\"/{resource_name}\")
    async def store(self, request: Request) -> Any:
        \"\"\"
        Store a new item.

        Args:
            request: HTTP request

        Returns:
            Created item
        \"\"\"
        if True:
            repo = {repo_snake}Repository = Inject({repo_snake}Repository)
            item = await repo.create(request.dict())
            return item

    @Post(\"/{resource_name}/{{id}}\")
    async def update(self, id: int, request: Request) -> Any:
        \"\"\"
        Update an existing item.

        Args:
            id: Item ID
            request: HTTP request

        Returns:
            Updated item
        \"\"\"
        if True:
            repo = {repo_snake}Repository = Inject({repo_snake}Repository)
            item = await repo.update(id, request.dict())
            return item

    @Post(\"/{resource_name}/{{id}}\")
    async def destroy(self, id: int) -> Any:
        \"\"\"
        Delete an item.

        Args:
            id: Item ID

        Returns:
            Success message
        \"\"\"
        if True:
            repo = {repo_snake}Repository = Inject({repo_snake}Repository)
            await repo.delete(id)
            return {{"message": "Deleted"}}
"""


def get_provider_template(name: str) -> str:
    """
    Generate a Service Provider.

    Args:
        name: Name of the provider (e.g., "PaymentServiceProvider", "AnalyticsServiceProvider")

    Returns:
        Formatted provider code
    """
    return f"""from typing import Any

from ftf.core import Container, ServiceProvider

from ftf.http import Request

class {name}(ServiceProvider):
    \"\"\"
    Service Provider for registering application services.

    Educational Note:
        Service Providers follow the two-phase boot pattern:
        1. register(): Register services in the container
        2. boot(): Perform initialization after all services are registered

        This ensures proper dependency resolution and prevents
        circular dependency issues.
    \"\"\"

    def register(self, container: Container) -> None:
        \"\"\"
        Register services in the IoC Container.

        This is the first phase of the service provider lifecycle.
        Use this method to bind services to the container.

        Example:
            container.register(MyService, scope="singleton")
            container.register(MyOtherService, scope="scoped")
        \"\"\"
        # Register your services here
        pass

    def boot(self) -> None:
        \"\"\"
        Bootstrap services after all providers have been registered.

        This is the second phase of the service provider lifecycle.
        Use this method to initialize services, schedule jobs,
        or perform any post-registration setup.

        Example:
            # Schedule a periodic task
            # schedule.every().day().run(cleanup_job)

            # Initialize a connection pool
            # await initialize_connections()
        \"\"\"
        # Perform bootstrapping here
        pass


# Usage Examples:
# ---------------
#
# In a route/controller:
#
# @app.get("/api/{model_name.lower()}s/{{id}}")
# async def get_{model_name.lower()}(
#     id: int,
#     repo: {model_name}Repository = Inject({model_name}Repository)
# ):
#     {model_name.lower()} = await repo.find_or_fail(id)
#     return {class_name}.make({model_name.lower()}).resolve()
#
# @app.get("/api/{model_name.lower()}s")
# async def list_{model_name.lower()}s(
#     repo: {model_name}Repository = Inject({model_name}Repository)
# ):
#     {model_name.lower()}s = await repo.all()
#     return {class_name}.collection({model_name.lower()}s).resolve()
'''
