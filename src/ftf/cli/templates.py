"""
Code Templates for Scaffolding (Sprint 3.0)

This module contains code templates for generating framework components.
Templates use Python f-strings for simplicity and enforce architectural
standards (e.g., warning docstrings in FormRequest).

Educational Note:
    Unlike Laravel which uses PHP Blade templates or Django which uses
    custom template syntax, we use Python f-strings because:
    1. No additional dependencies
    2. Type-safe and validated by MyPy
    3. Familiar to Python developers
    4. Easy to test and maintain

Templates Available:
    - MODEL_TEMPLATE: SQLAlchemy model with mixins
    - REPOSITORY_TEMPLATE: Repository inheriting BaseRepository
    - REQUEST_TEMPLATE: FormRequest with validation methods (includes warning)
    - FACTORY_TEMPLATE: Factory for test data generation
    - SEEDER_TEMPLATE: Seeder for database seeding
"""


def get_model_template(class_name: str, table_name: str) -> str:
    """
    Generate a SQLAlchemy model with TimestampMixin and SoftDeletesMixin.

    Args:
        class_name: Name of the model class (e.g., "User", "Post")
        table_name: Name of the database table (e.g., "users", "posts")

    Returns:
        Formatted model code with proper imports and structure

    Example:
        >>> get_model_template("User", "users")
        # Returns model code with User class
    """
    return f'''"""
{class_name} Model

This module defines the {class_name} model for database operations.
Generated by Fast Track Framework CLI.
"""

from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column

from fast_query import Base, SoftDeletesMixin, TimestampMixin


class {class_name}(Base, TimestampMixin, SoftDeletesMixin):
    """
    {class_name} model.

    This model includes automatic timestamp management (created_at, updated_at)
    and soft delete functionality (deleted_at).

    Attributes:
        id: Primary key
        name: {class_name} name
        # Add more fields as needed
    """

    __tablename__ = "{table_name}"

    # Primary key
    id: Mapped[int] = mapped_column(primary_key=True)

    # Fields
    name: Mapped[str] = mapped_column(String(100))

    # TODO: Add more columns here
    # Example:
    # email: Mapped[str] = mapped_column(String(255), unique=True)
    # is_active: Mapped[bool] = mapped_column(default=True)

    # TODO: Define relationships here
    # Example:
    # posts: Mapped[list["Post"]] = relationship("Post", back_populates="user")

    def __repr__(self) -> str:
        """String representation for debugging."""
        return f"<{class_name}(id={{self.id}}, name={{self.name}})>"
'''


def get_repository_template(class_name: str, model_name: str) -> str:
    """
    Generate a repository inheriting BaseRepository.

    Args:
        class_name: Name of the repository class (e.g., "UserRepository")
        model_name: Name of the model class (e.g., "User")

    Returns:
        Formatted repository code

    Example:
        >>> get_repository_template("UserRepository", "User")
        # Returns repository code
    """
    return f'''"""
{class_name}

This module defines the repository for {model_name} operations.
Generated by Fast Track Framework CLI.
"""

from sqlalchemy.ext.asyncio import AsyncSession

from fast_query import BaseRepository
from ftf.models import {model_name}


class {class_name}(BaseRepository[{model_name}]):
    """
    Repository for {model_name} database operations.

    Inherits from BaseRepository which provides:
    - find(id): Find by primary key
    - find_or_fail(id): Find or raise RecordNotFound
    - all(): Get all records
    - paginate(page, per_page): Paginated results
    - create(data): Create new record
    - update(id, data): Update existing record
    - delete(id): Delete record (soft delete if mixin enabled)

    Add custom query methods here.

    Example:
        >>> async with get_session() as session:
        ...     repo = {class_name}(session)
        ...     user = await repo.find_or_fail(1)
    """

    def __init__(self, session: AsyncSession):
        """
        Initialize repository.

        Args:
            session: AsyncSession for database operations
        """
        super().__init__(session, {model_name})

    # TODO: Add custom query methods here
    # Example:
    # async def find_by_email(self, email: str) -> {model_name} | None:
    #     """Find {model_name.lower()} by email address."""
    #     result = await self.session.execute(
    #         select({model_name}).where({model_name}.email == email)
    #     )
    #     return result.scalar_one_or_none()
'''


def get_request_template(class_name: str) -> str:
    """
    Generate a FormRequest with validation methods.

    This template includes the GOVERNANCE WARNING about side effects in rules().

    Args:
        class_name: Name of the request class (e.g., "StoreUserRequest")

    Returns:
        Formatted request code with warning docstring

    Example:
        >>> get_request_template("StoreUserRequest")
        # Returns request code with warning
    """
    return f'''"""
{class_name}

This module defines the form request for validation.
Generated by Fast Track Framework CLI.

⚠️ WARNING: rules() is for data validation only.
DO NOT mutate data or perform side effects here.
"""

from pydantic import EmailStr
from sqlalchemy.ext.asyncio import AsyncSession

from ftf.models import User  # Import your model
from ftf.validation import FormRequest, Rule


class {class_name}(FormRequest):
    """
    Form request for validating data.

    This class combines Pydantic's structural validation with async
    database validation. It follows the "best of both worlds" approach:
    - Pydantic handles types, required fields, formats
    - async methods handle database checks (unique, exists)

    Attributes:
        # TODO: Define your fields here
        name: str
        email: EmailStr

    Example:
        >>> @app.post("/endpoint")
        ... async def create(request: {class_name} = Validate({class_name})):
        ...     # request is fully validated!
        ...     return {{"message": "Success"}}
    """

    # TODO: Define your fields with Pydantic validation
    name: str
    email: EmailStr

    async def authorize(self, session: AsyncSession) -> bool:
        """
        Determine if the user is authorized to make this request.

        Override this method to implement authorization logic. By default,
        all requests are authorized (returns True).

        Returns 403 Forbidden if this returns False.

        Args:
            session: AsyncSession for database queries

        Returns:
            bool: True if authorized, False otherwise

        Example:
            >>> async def authorize(self, session: AsyncSession) -> bool:
            ...     # Check if user is admin
            ...     current_user = await get_current_user()
            ...     return current_user.is_admin
        """
        return True

    async def rules(self, session: AsyncSession) -> None:
        """
        Define custom validation rules.

        ⚠️ WARNING: This method is for DATA VALIDATION ONLY.
        DO NOT:
        - Mutate data (self.field = new_value)
        - Perform side effects (send emails, update database)
        - Execute business logic (create records, process payments)

        Returns 422 Unprocessable Entity if validation fails.

        Args:
            session: AsyncSession for database queries

        Raises:
            ValidationError: If validation fails

        Example:
            >>> async def rules(self, session: AsyncSession) -> None:
            ...     # Check email is unique
            ...     await Rule.unique(session, User, "email", self.email)
            ...
            ...     # Custom validation
            ...     if self.age < 18:
            ...         self.stop("You must be 18 or older")
        """
        # TODO: Add validation rules here
        # Example: Check if email is unique
        # await Rule.unique(session, User, "email", self.email)
        pass
'''


def get_factory_template(class_name: str, model_name: str) -> str:
    """
    Generate a factory for test data generation.

    Args:
        class_name: Name of the factory class (e.g., "UserFactory")
        model_name: Name of the model class (e.g., "User")

    Returns:
        Formatted factory code

    Example:
        >>> get_factory_template("UserFactory", "User")
        # Returns factory code
    """
    return f'''"""
{class_name}

This module defines a factory for generating {model_name} test data.
Generated by Fast Track Framework CLI.
"""

from typing import Any

from fast_query import Factory
from ftf.models import {model_name}


class {class_name}(Factory[{model_name}]):
    """
    Factory for generating {model_name} instances.

    This factory uses Faker to generate realistic fake data for testing.
    It inherits from Factory which provides:
    - create(): Create one instance
    - create_batch(count): Create multiple instances
    - state(callable): Modify attributes
    - Relationship hooks (if defined)

    Example:
        >>> async with get_session() as session:
        ...     factory = {class_name}(session)
        ...     user = await factory.create()
        ...     users = await factory.create_batch(10)
    """

    _model_class = {model_name}

    def definition(self) -> dict[str, Any]:
        """
        Define the default attributes for the model.

        This method uses self.faker to generate fake data. Faker provides
        many useful generators like name(), email(), address(), etc.

        Returns:
            dict: Default attributes for {model_name}

        Example:
            >>> def definition(self) -> dict[str, Any]:
            ...     return {{
            ...         "name": self.faker.name(),
            ...         "email": self.faker.email(),
            ...     }}
        """
        return {{
            "name": self.faker.name(),
            # TODO: Add more fields here
            # Example:
            # "email": self.faker.email(),
            # "is_active": True,
        }}

    # TODO: Add relationship hooks here
    # Example:
    # async def has_posts(self, count: int = 3) -> "UserFactory":
    #     """Create user with posts."""
    #     def after_create(user: User) -> None:
    #         self._after_create_callbacks.append(
    #             lambda: PostFactory(self.session).create_batch(count, user_id=user.id)
    #         )
    #     self._after_create_callbacks.append(after_create)
    #     return self
'''


def get_seeder_template(class_name: str) -> str:
    """
    Generate a seeder for database seeding.

    Args:
        class_name: Name of the seeder class (e.g., "UserSeeder")

    Returns:
        Formatted seeder code

    Example:
        >>> get_seeder_template("UserSeeder")
        # Returns seeder code
    """
    return f'''"""
{class_name}

This module defines a database seeder.
Generated by Fast Track Framework CLI.
"""

from fast_query import Seeder

# Import your factories here
# from tests.factories import UserFactory


class {class_name}(Seeder):
    """
    Seeder for populating the database.

    This seeder uses factories to generate test/initial data.
    It inherits from Seeder which provides:
    - self.session: AsyncSession for database operations
    - run(): Method to execute seeding logic

    Example:
        >>> async with get_session() as session:
        ...     seeder = {class_name}(session)
        ...     await seeder.run()
    """

    async def run(self) -> None:
        """
        Run the database seeder.

        This method is called when you execute `ftf db:seed`.
        Use factories to create test data here.

        Example:
            >>> async def run(self) -> None:
            ...     factory = UserFactory(self.session)
            ...     await factory.create_batch(10)
        """
        # TODO: Add seeding logic here
        # Example:
        # factory = UserFactory(self.session)
        # await factory.create_batch(10)
        pass
'''


def get_event_template(class_name: str) -> str:
    """
    Generate an Event class (DTO).

    Args:
        class_name: Name of the event class (e.g., "UserRegistered")

    Returns:
        Formatted event code

    Example:
        >>> get_event_template("UserRegistered")
        # Returns event code
    """
    return f'''"""
{class_name} Event

This module defines an event that can be dispatched through the Event Bus.
Generated by Fast Track Framework CLI.

Educational Note:
    Events are DTOs (Data Transfer Objects) that carry information about
    something that happened. They should be immutable and contain only data.
"""

from dataclasses import dataclass

from ftf.events import Event


@dataclass
class {class_name}(Event):
    """
    Event fired when {class_name.lower().replace("event", "")} occurs.

    This event carries information about the occurrence and can be handled
    by multiple listeners concurrently.

    Attributes:
        # TODO: Define your event attributes here
        # Example:
        # user_id: int
        # email: str
        # timestamp: datetime

    Example:
        >>> event = {class_name}(user_id=1, email="user@test.com")
        >>> await dispatch(event)
    """

    # TODO: Add your event attributes here
    # Example for a user registration event:
    # user_id: int
    # email: str
    # name: str
    # timestamp: datetime = field(default_factory=datetime.utcnow)

    pass
'''


def get_listener_template(class_name: str, event_name: str = "Event") -> str:
    """
    Generate a Listener class for handling events.

    Args:
        class_name: Name of the listener class (e.g., "SendWelcomeEmail")
        event_name: Name of the event this listener handles

    Returns:
        Formatted listener code

    Example:
        >>> get_listener_template("SendWelcomeEmail", "UserRegistered")
        # Returns listener code
    """
    return f'''"""
{class_name} Listener

This module defines a listener that handles {event_name} events.
Generated by Fast Track Framework CLI.

Educational Note:
    Listeners are resolved from the IoC Container, so you can inject
    dependencies (repositories, services, etc.) via __init__.
"""

from ftf.events import Listener

# TODO: Import your event
# from ftf.events.user_registered import UserRegistered
from ftf.events import Event as {event_name}  # Replace with actual import


class {class_name}(Listener[{event_name}]):
    """
    Handles {event_name} events.

    This listener is resolved from the IoC Container, allowing dependency
    injection of repositories, services, mailers, etc.

    Example:
        >>> class {class_name}(Listener[UserRegistered]):
        ...     def __init__(self, mailer: MailService, user_repo: UserRepository):
        ...         self.mailer = mailer
        ...         self.user_repo = user_repo
        ...
        ...     async def handle(self, event: UserRegistered) -> None:
        ...         user = await self.user_repo.find(event.user_id)
        ...         await self.mailer.send(user.email, "Welcome!")
    """

    def __init__(self) -> None:
        """
        Initialize the listener.

        TODO: Add dependencies here via dependency injection.

        Example:
            def __init__(self, mailer: MailService):
                self.mailer = mailer
        """
        pass

    async def handle(self, event: {event_name}) -> None:
        """
        Handle the {event_name} event.

        This method is called when the event is dispatched. Add your
        business logic here.

        Args:
            event: The event instance containing data

        Example:
            >>> async def handle(self, event: UserRegistered) -> None:
            ...     # Send welcome email
            ...     await self.mailer.send(
            ...         to=event.email,
            ...         subject="Welcome!",
            ...         body=f"Hello {{event.name}}!"
            ...     )
        """
        # TODO: Add your event handling logic here
        # Example:
        # await self.mailer.send(event.email, "Welcome!")
        pass
'''


def get_job_template(class_name: str) -> str:
    """
    Generate a Job class for background processing.

    Args:
        class_name: Name of the job class (e.g., "SendWelcomeEmail")

    Returns:
        Formatted job code

    Example:
        >>> get_job_template("SendWelcomeEmail")
        # Returns job code with async handle() method
    """
    return f'''"""
{class_name} Job

This module defines a background job.
Generated by Fast Track Framework CLI.
"""

from ftf.jobs import Job

# Import your dependencies here
# from ftf.repositories import UserRepository
# from ftf.services import MailerService


class {class_name}(Job):
    """
    {class_name} background job.

    This job processes work asynchronously in the background. Jobs can receive
    dependencies through the IoC Container, making them testable and maintainable.

    Dependencies are injected via __init__, and payload attributes are set
    by the runner before handle() is called.

    Example:
        >>> # Define job with dependencies
        >>> class {class_name}(Job):
        ...     def __init__(self, mailer: MailerService):
        ...         self.mailer = mailer
        ...         self.email: str = ""  # Set by payload
        ...
        ...     async def handle(self) -> None:
        ...         await self.mailer.send(self.email, "Hello!")
        >>>
        >>> # Dispatch job
        >>> await {class_name}.dispatch(email="user@test.com")
    """

    def __init__(self) -> None:
        """
        Initialize the job with dependencies.

        Dependencies are resolved from the IoC Container. Add any repositories,
        services, or other dependencies as parameters.

        Example:
            >>> def __init__(self, user_repo: UserRepository, mailer: MailerService):
            ...     self.user_repo = user_repo
            ...     self.mailer = mailer
            ...     # Payload attributes (set by dispatcher):
            ...     self.user_id: int = 0
            ...     self.email: str = ""
        """
        # TODO: Add dependencies as parameters
        # TODO: Initialize payload attributes with default values
        pass

    async def handle(self) -> None:
        """
        Execute the job logic.

        This method contains the actual work to be performed. Payload attributes
        are already set by the runner before this method is called.

        Raises:
            Exception: Any exceptions will be logged by SAQ and can trigger retries

        Example:
            >>> async def handle(self) -> None:
            ...     user = await self.user_repo.find(self.user_id)
            ...     await self.mailer.send(
            ...         to=user.email,
            ...         subject="Welcome!",
            ...         body=f"Hello {{user.name}}!"
            ...     )
        """
        # TODO: Add your job logic here
        # Example:
        # user = await self.user_repo.find(self.user_id)
        # await self.mailer.send(user.email, "Welcome!")
        pass
'''


def get_auth_controller_template() -> str:
    """Generate an authentication controller with login, register, and me endpoints."""
    return '''"""
Authentication Controller (Generated by ftf make:auth)

This controller handles user authentication endpoints:
- POST /auth/register - Create new user account
- POST /auth/login - Authenticate and get JWT token
- GET /auth/me - Get current authenticated user
"""

from fastapi import APIRouter, HTTPException, status

from ftf.auth import CurrentUser, create_access_token, hash_password, verify_password
from ftf.http.requests.auth.login_request import LoginRequest
from ftf.http.requests.auth.register_request import RegisterRequest
from ftf.repositories.user_repository import UserRepository

router = APIRouter(prefix="/auth", tags=["authentication"])


@router.post("/register", status_code=status.HTTP_201_CREATED)
async def register(
    request: RegisterRequest,
    user_repo: UserRepository,
) -> dict:
    """
    Register a new user account.

    This endpoint:
    1. Validates the request data (email, password, name)
    2. Checks if email is already registered (via FormRequest validation)
    3. Hashes the password with bcrypt
    4. Creates the user in the database
    5. Returns success message

    Args:
        request: Validated registration data
        user_repo: User repository (auto-injected)

    Returns:
        dict: Success message with user ID

    Raises:
        HTTPException: 422 if validation fails (duplicate email, weak password, etc.)
    """
    # Hash the password before storing
    hashed_password = hash_password(request.password)

    # Create the user
    user = await user_repo.create({
        "name": request.name,
        "email": request.email,
        "password": hashed_password,
    })

    return {
        "message": "User registered successfully",
        "user_id": user.id,
    }


@router.post("/login")
async def login(
    request: LoginRequest,
    user_repo: UserRepository,
) -> dict:
    """
    Authenticate user and return JWT access token.

    This endpoint:
    1. Validates the request data (email, password)
    2. Finds the user by email
    3. Verifies the password hash
    4. Generates a JWT access token
    5. Returns the token

    Args:
        request: Login credentials
        user_repo: User repository (auto-injected)

    Returns:
        dict: Access token and token type

    Raises:
        HTTPException: 401 if credentials are invalid
    """
    # Find user by email
    user = await user_repo.where("email", request.email).first()

    # Check if user exists and password is correct
    if not user or not verify_password(request.password, user.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Generate JWT token
    access_token = create_access_token(data={"user_id": user.id})

    return {
        "access_token": access_token,
        "token_type": "bearer",
    }


@router.get("/me")
async def get_current_user_info(user: CurrentUser) -> dict:
    """
    Get the currently authenticated user's information.

    This endpoint demonstrates route protection with JWT.
    The CurrentUser dependency automatically:
    1. Extracts the JWT token from the Authorization header
    2. Verifies the token signature and expiration
    3. Fetches the user from the database
    4. Returns the user instance

    Args:
        user: Current authenticated user (auto-injected via JWT)

    Returns:
        dict: User information

    Example:
        GET /auth/me
        Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

        Response:
        {
            "id": 1,
            "name": "John Doe",
            "email": "john@example.com"
        }
    """
    return {
        "id": user.id,
        "name": user.name,
        "email": user.email,
    }
'''


def get_login_request_template() -> str:
    """Generate a login request with email and password validation."""
    return '''"""
Login Request (Generated by ftf make:auth)

Validates user login credentials.
"""

from ftf.validation import FormRequest, Rule


class LoginRequest(FormRequest):
    """
    Validates login credentials.

    Fields:
        - email: Required, must be valid email format
        - password: Required, minimum length
    """

    email: str
    password: str

    def rules(self) -> dict[str, list[Rule]]:
        """
        Define validation rules for login.

        ⚠️ WARNING: This method is for DATA VALIDATION ONLY.
        DO NOT perform side effects here (database queries, API calls, etc.)
        Side effects belong in the controller AFTER validation passes.
        """
        return {
            "email": [
                Rule.required(),
                Rule.email(),
            ],
            "password": [
                Rule.required(),
                Rule.min_length(6),
            ],
        }
'''


def get_register_request_template() -> str:
    """Generate a register request with validation including unique email."""
    return '''"""
Register Request (Generated by ftf make:auth)

Validates new user registration data.
"""

from ftf.validation import FormRequest, Rule


class RegisterRequest(FormRequest):
    """
    Validates user registration data.

    Fields:
        - name: Required, minimum 2 characters
        - email: Required, valid email, must be unique
        - password: Required, minimum 8 characters
        - password_confirmation: Required, must match password
    """

    name: str
    email: str
    password: str
    password_confirmation: str

    def rules(self) -> dict[str, list[Rule]]:
        """
        Define validation rules for registration.

        ⚠️ WARNING: This method is for DATA VALIDATION ONLY.
        DO NOT perform side effects here (database queries, API calls, etc.)
        Side effects belong in the controller AFTER validation passes.
        """
        return {
            "name": [
                Rule.required(),
                Rule.min_length(2),
                Rule.max_length(100),
            ],
            "email": [
                Rule.required(),
                Rule.email(),
                Rule.unique("users", "email"),  # Check email uniqueness in database
            ],
            "password": [
                Rule.required(),
                Rule.min_length(8),
                Rule.max_length(100),
            ],
            "password_confirmation": [
                Rule.required(),
                Rule.confirmed("password"),  # Must match password field
            ],
        }
'''


def get_user_model_template() -> str:
    """Generate a User model with authentication fields."""
    return '''"""
User Model (Generated by ftf make:auth)

User model with authentication fields (email, password).
"""

from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column

from fast_query import Base, SoftDeletesMixin, TimestampMixin


class User(Base, TimestampMixin, SoftDeletesMixin):
    """
    User model with authentication.

    This model includes:
    - Auto-timestamps (created_at, updated_at)
    - Soft deletes (deleted_at)
    - Authentication fields (email, password)

    Attributes:
        id: Primary key
        name: User's full name
        email: Unique email address
        password: Bcrypt-hashed password (NEVER store plain text!)
    """

    __tablename__ = "users"

    # Primary key
    id: Mapped[int] = mapped_column(primary_key=True)

    # User information
    name: Mapped[str] = mapped_column(String(100))
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)

    # Authentication (password is hashed with bcrypt)
    password: Mapped[str] = mapped_column(String(255))

    # TODO: Add more fields as needed
    # Example:
    # is_active: Mapped[bool] = mapped_column(default=True)
    # is_admin: Mapped[bool] = mapped_column(default=False)

    def __repr__(self) -> str:
        """String representation for debugging."""
        return f"<User(id={self.id}, email={self.email})>"
'''


def get_user_repository_template() -> str:
    """Generate a UserRepository."""
    return '''"""
User Repository (Generated by ftf make:auth)

Repository for User database operations.
"""

from fast_query import BaseRepository
from ftf.models.user import User


class UserRepository(BaseRepository[User]):
    """
    User repository with CRUD operations.

    Inherits all methods from BaseRepository:
    - create(data)
    - find(id)
    - find_or_fail(id)
    - update(id, data)
    - delete(id)
    - all()
    - where(column, value)
    - paginate(page, per_page)

    Add custom user-specific methods here as needed.
    """

    # Example custom method:
    # async def find_by_email(self, email: str) -> User | None:
    #     """Find user by email address."""
    #     return await self.where("email", email).first()
'''


# Template mapping for easy access
TEMPLATES = {
    "model": get_model_template,
    "repository": get_repository_template,
    "request": get_request_template,
    "factory": get_factory_template,
    "seeder": get_seeder_template,
    "event": get_event_template,
    "listener": get_listener_template,
    "job": get_job_template,
    "auth_controller": get_auth_controller_template,
    "login_request": get_login_request_template,
    "register_request": get_register_request_template,
    "user_model": get_user_model_template,
    "user_repository": get_user_repository_template,
}
