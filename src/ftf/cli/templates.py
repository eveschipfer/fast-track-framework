"""
Code Templates for Scaffolding (Sprint 3.0)

This module contains code templates for generating framework components.
Templates use Python f-strings for simplicity and enforce architectural
standards (e.g., warning docstrings in FormRequest).

Educational Note:
    Unlike Laravel which uses PHP Blade templates or Django which uses
    custom template syntax, we use Python f-strings because:
    1. No additional dependencies
    2. Type-safe and validated by MyPy
    3. Familiar to Python developers
    4. Easy to test and maintain

Templates Available:
    - MODEL_TEMPLATE: SQLAlchemy model with mixins
    - REPOSITORY_TEMPLATE: Repository inheriting BaseRepository
    - REQUEST_TEMPLATE: FormRequest with validation methods (includes warning)
    - FACTORY_TEMPLATE: Factory for test data generation
    - SEEDER_TEMPLATE: Seeder for database seeding
"""


def get_model_template(class_name: str, table_name: str) -> str:
    """
    Generate a SQLAlchemy model with TimestampMixin and SoftDeletesMixin.

    Args:
        class_name: Name of the model class (e.g., "User", "Post")
        table_name: Name of the database table (e.g., "users", "posts")

    Returns:
        Formatted model code with proper imports and structure

    Example:
        >>> get_model_template("User", "users")
        # Returns model code with User class
    """
    return f'''"""
{class_name} Model

This module defines the {class_name} model for database operations.
Generated by Fast Track Framework CLI.
"""

from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column

from fast_query import Base, SoftDeletesMixin, TimestampMixin


class {class_name}(Base, TimestampMixin, SoftDeletesMixin):
    """
    {class_name} model.

    This model includes automatic timestamp management (created_at, updated_at)
    and soft delete functionality (deleted_at).

    Attributes:
        id: Primary key
        name: {class_name} name
        # Add more fields as needed
    """

    __tablename__ = "{table_name}"

    # Primary key
    id: Mapped[int] = mapped_column(primary_key=True)

    # Fields
    name: Mapped[str] = mapped_column(String(100))

    # TODO: Add more columns here
    # Example:
    # email: Mapped[str] = mapped_column(String(255), unique=True)
    # is_active: Mapped[bool] = mapped_column(default=True)

    # TODO: Define relationships here
    # Example:
    # posts: Mapped[list["Post"]] = relationship("Post", back_populates="user")

    def __repr__(self) -> str:
        """String representation for debugging."""
        return f"<{class_name}(id={{self.id}}, name={{self.name}})>"
'''


def get_repository_template(class_name: str, model_name: str) -> str:
    """
    Generate a repository inheriting BaseRepository.

    Args:
        class_name: Name of the repository class (e.g., "UserRepository")
        model_name: Name of the model class (e.g., "User")

    Returns:
        Formatted repository code

    Example:
        >>> get_repository_template("UserRepository", "User")
        # Returns repository code
    """
    return f'''"""
{class_name}

This module defines the repository for {model_name} operations.
Generated by Fast Track Framework CLI.
"""

from sqlalchemy.ext.asyncio import AsyncSession

from fast_query import BaseRepository
from ftf.models import {model_name}


class {class_name}(BaseRepository[{model_name}]):
    """
    Repository for {model_name} database operations.

    Inherits from BaseRepository which provides:
    - find(id): Find by primary key
    - find_or_fail(id): Find or raise RecordNotFound
    - all(): Get all records
    - paginate(page, per_page): Paginated results
    - create(data): Create new record
    - update(id, data): Update existing record
    - delete(id): Delete record (soft delete if mixin enabled)

    Add custom query methods here.

    Example:
        >>> async with get_session() as session:
        ...     repo = {class_name}(session)
        ...     user = await repo.find_or_fail(1)
    """

    def __init__(self, session: AsyncSession):
        """
        Initialize repository.

        Args:
            session: AsyncSession for database operations
        """
        super().__init__(session, {model_name})

    # TODO: Add custom query methods here
    # Example:
    # async def find_by_email(self, email: str) -> {model_name} | None:
    #     """Find {model_name.lower()} by email address."""
    #     result = await self.session.execute(
    #         select({model_name}).where({model_name}.email == email)
    #     )
    #     return result.scalar_one_or_none()
'''


def get_request_template(class_name: str) -> str:
    """
    Generate a FormRequest with validation methods.

    This template includes the GOVERNANCE WARNING about side effects in rules().

    Args:
        class_name: Name of the request class (e.g., "StoreUserRequest")

    Returns:
        Formatted request code with warning docstring

    Example:
        >>> get_request_template("StoreUserRequest")
        # Returns request code with warning
    """
    return f'''"""
{class_name}

This module defines the form request for validation.
Generated by Fast Track Framework CLI.

⚠️ WARNING: rules() is for data validation only.
DO NOT mutate data or perform side effects here.
"""

from pydantic import EmailStr
from sqlalchemy.ext.asyncio import AsyncSession

from ftf.models import User  # Import your model
from ftf.validation import FormRequest, Rule


class {class_name}(FormRequest):
    """
    Form request for validating data.

    This class combines Pydantic's structural validation with async
    database validation. It follows the "best of both worlds" approach:
    - Pydantic handles types, required fields, formats
    - async methods handle database checks (unique, exists)

    Attributes:
        # TODO: Define your fields here
        name: str
        email: EmailStr

    Example:
        >>> @app.post("/endpoint")
        ... async def create(request: {class_name} = Validate({class_name})):
        ...     # request is fully validated!
        ...     return {{"message": "Success"}}
    """

    # TODO: Define your fields with Pydantic validation
    name: str
    email: EmailStr

    async def authorize(self, session: AsyncSession) -> bool:
        """
        Determine if the user is authorized to make this request.

        Override this method to implement authorization logic. By default,
        all requests are authorized (returns True).

        Returns 403 Forbidden if this returns False.

        Args:
            session: AsyncSession for database queries

        Returns:
            bool: True if authorized, False otherwise

        Example:
            >>> async def authorize(self, session: AsyncSession) -> bool:
            ...     # Check if user is admin
            ...     current_user = await get_current_user()
            ...     return current_user.is_admin
        """
        return True

    async def rules(self, session: AsyncSession) -> None:
        """
        Define custom validation rules.

        ⚠️ WARNING: This method is for DATA VALIDATION ONLY.
        DO NOT:
        - Mutate data (self.field = new_value)
        - Perform side effects (send emails, update database)
        - Execute business logic (create records, process payments)

        Returns 422 Unprocessable Entity if validation fails.

        Args:
            session: AsyncSession for database queries

        Raises:
            ValidationError: If validation fails

        Example:
            >>> async def rules(self, session: AsyncSession) -> None:
            ...     # Check email is unique
            ...     await Rule.unique(session, User, "email", self.email)
            ...
            ...     # Custom validation
            ...     if self.age < 18:
            ...         self.stop("You must be 18 or older")
        """
        # TODO: Add validation rules here
        # Example: Check if email is unique
        # await Rule.unique(session, User, "email", self.email)
        pass
'''


def get_factory_template(class_name: str, model_name: str) -> str:
    """
    Generate a factory for test data generation.

    Args:
        class_name: Name of the factory class (e.g., "UserFactory")
        model_name: Name of the model class (e.g., "User")

    Returns:
        Formatted factory code

    Example:
        >>> get_factory_template("UserFactory", "User")
        # Returns factory code
    """
    return f'''"""
{class_name}

This module defines a factory for generating {model_name} test data.
Generated by Fast Track Framework CLI.
"""

from typing import Any

from fast_query import Factory
from ftf.models import {model_name}


class {class_name}(Factory[{model_name}]):
    """
    Factory for generating {model_name} instances.

    This factory uses Faker to generate realistic fake data for testing.
    It inherits from Factory which provides:
    - create(): Create one instance
    - create_batch(count): Create multiple instances
    - state(callable): Modify attributes
    - Relationship hooks (if defined)

    Example:
        >>> async with get_session() as session:
        ...     factory = {class_name}(session)
        ...     user = await factory.create()
        ...     users = await factory.create_batch(10)
    """

    _model_class = {model_name}

    def definition(self) -> dict[str, Any]:
        """
        Define the default attributes for the model.

        This method uses self.faker to generate fake data. Faker provides
        many useful generators like name(), email(), address(), etc.

        Returns:
            dict: Default attributes for {model_name}

        Example:
            >>> def definition(self) -> dict[str, Any]:
            ...     return {{
            ...         "name": self.faker.name(),
            ...         "email": self.faker.email(),
            ...     }}
        """
        return {{
            "name": self.faker.name(),
            # TODO: Add more fields here
            # Example:
            # "email": self.faker.email(),
            # "is_active": True,
        }}

    # TODO: Add relationship hooks here
    # Example:
    # async def has_posts(self, count: int = 3) -> "UserFactory":
    #     """Create user with posts."""
    #     def after_create(user: User) -> None:
    #         self._after_create_callbacks.append(
    #             lambda: PostFactory(self.session).create_batch(count, user_id=user.id)
    #         )
    #     self._after_create_callbacks.append(after_create)
    #     return self
'''


def get_seeder_template(class_name: str) -> str:
    """
    Generate a seeder for database seeding.

    Args:
        class_name: Name of the seeder class (e.g., "UserSeeder")

    Returns:
        Formatted seeder code

    Example:
        >>> get_seeder_template("UserSeeder")
        # Returns seeder code
    """
    return f'''"""
{class_name}

This module defines a database seeder.
Generated by Fast Track Framework CLI.
"""

from fast_query import Seeder

# Import your factories here
# from tests.factories import UserFactory


class {class_name}(Seeder):
    """
    Seeder for populating the database.

    This seeder uses factories to generate test/initial data.
    It inherits from Seeder which provides:
    - self.session: AsyncSession for database operations
    - run(): Method to execute seeding logic

    Example:
        >>> async with get_session() as session:
        ...     seeder = {class_name}(session)
        ...     await seeder.run()
    """

    async def run(self) -> None:
        """
        Run the database seeder.

        This method is called when you execute `ftf db:seed`.
        Use factories to create test data here.

        Example:
            >>> async def run(self) -> None:
            ...     factory = UserFactory(self.session)
            ...     await factory.create_batch(10)
        """
        # TODO: Add seeding logic here
        # Example:
        # factory = UserFactory(self.session)
        # await factory.create_batch(10)
        pass
'''


def get_event_template(class_name: str) -> str:
    """
    Generate an Event class (DTO).

    Args:
        class_name: Name of the event class (e.g., "UserRegistered")

    Returns:
        Formatted event code

    Example:
        >>> get_event_template("UserRegistered")
        # Returns event code
    """
    return f'''"""
{class_name} Event

This module defines an event that can be dispatched through the Event Bus.
Generated by Fast Track Framework CLI.

Educational Note:
    Events are DTOs (Data Transfer Objects) that carry information about
    something that happened. They should be immutable and contain only data.
"""

from dataclasses import dataclass

from ftf.events import Event


@dataclass
class {class_name}(Event):
    """
    Event fired when {class_name.lower().replace("event", "")} occurs.

    This event carries information about the occurrence and can be handled
    by multiple listeners concurrently.

    Attributes:
        # TODO: Define your event attributes here
        # Example:
        # user_id: int
        # email: str
        # timestamp: datetime

    Example:
        >>> event = {class_name}(user_id=1, email="user@test.com")
        >>> await dispatch(event)
    """

    # TODO: Add your event attributes here
    # Example for a user registration event:
    # user_id: int
    # email: str
    # name: str
    # timestamp: datetime = field(default_factory=datetime.utcnow)

    pass
'''


def get_listener_template(class_name: str, event_name: str = "Event") -> str:
    """
    Generate a Listener class for handling events.

    Args:
        class_name: Name of the listener class (e.g., "SendWelcomeEmail")
        event_name: Name of the event this listener handles

    Returns:
        Formatted listener code

    Example:
        >>> get_listener_template("SendWelcomeEmail", "UserRegistered")
        # Returns listener code
    """
    return f'''"""
{class_name} Listener

This module defines a listener that handles {event_name} events.
Generated by Fast Track Framework CLI.

Educational Note:
    Listeners are resolved from the IoC Container, so you can inject
    dependencies (repositories, services, etc.) via __init__.
"""

from ftf.events import Listener

# TODO: Import your event
# from ftf.events.user_registered import UserRegistered
from ftf.events import Event as {event_name}  # Replace with actual import


class {class_name}(Listener[{event_name}]):
    """
    Handles {event_name} events.

    This listener is resolved from the IoC Container, allowing dependency
    injection of repositories, services, mailers, etc.

    Example:
        >>> class {class_name}(Listener[UserRegistered]):
        ...     def __init__(self, mailer: MailService, user_repo: UserRepository):
        ...         self.mailer = mailer
        ...         self.user_repo = user_repo
        ...
        ...     async def handle(self, event: UserRegistered) -> None:
        ...         user = await self.user_repo.find(event.user_id)
        ...         await self.mailer.send(user.email, "Welcome!")
    """

    def __init__(self) -> None:
        """
        Initialize the listener.

        TODO: Add dependencies here via dependency injection.

        Example:
            def __init__(self, mailer: MailService):
                self.mailer = mailer
        """
        pass

    async def handle(self, event: {event_name}) -> None:
        """
        Handle the {event_name} event.

        This method is called when the event is dispatched. Add your
        business logic here.

        Args:
            event: The event instance containing data

        Example:
            >>> async def handle(self, event: UserRegistered) -> None:
            ...     # Send welcome email
            ...     await self.mailer.send(
            ...         to=event.email,
            ...         subject="Welcome!",
            ...         body=f"Hello {{event.name}}!"
            ...     )
        """
        # TODO: Add your event handling logic here
        # Example:
        # await self.mailer.send(event.email, "Welcome!")
        pass
'''


# Template mapping for easy access
TEMPLATES = {
    "model": get_model_template,
    "repository": get_repository_template,
    "request": get_request_template,
    "factory": get_factory_template,
    "seeder": get_seeder_template,
    "event": get_event_template,
    "listener": get_listener_template,
}
